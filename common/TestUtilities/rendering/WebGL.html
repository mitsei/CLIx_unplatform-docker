<html>

<head>
<title>WebGL Speed Test</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="sylvester.js"></script>
<script type="text/javascript" src="glUtils.js"></script>

<!-- The fragment/particle shader colors each point in a shape-->
<script id="shader-fs" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  // uColor is pointed to by shader program's array, and basically
  // filters the color of each square
  uniform vec3 uColor;

  void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * vec4(uColor, 1.0);
  }
</script>

<!-- The vertex shader spits out varying variables, i.e. the position of
     each vertex -->
     
<script id="shader-vs" type="x-shader/x-vertex">
  
  attribute vec3 aVertexPosition;

  // The model-view (how it's drawing) and perspective (how it's
  // being viewed) matrices
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>

<!-- Setting up the canvas -->
<script type="text/javascript">

  var gl;
  function initGL(canvas) {
    try {
      gl = canvas.getContext("webgl");
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    } catch(e) {
    }
    if (!gl) {
      alert("Could not initialise WebGL, sorry :-(");
    }
  }

  // Instantiates vertex and fragment shaders
  function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
      return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
      if (k.nodeType == 3) {
        str += k.textContent;
      }
      k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  }

  // Attaches the vertex and fragment shaders to the shader program
  var shaderProgram;
  function initShaders() {
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, "uColor");
  }

  // Various matrix operations
  var mvMatrix;
  var mvMatrixStack = [];

  function mvPushMatrix(m) {
    if (m) {
      mvMatrixStack.push(m.dup());
      mvMatrix = m.dup();
    } else {
      mvMatrixStack.push(mvMatrix.dup());
    }
  }

  function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
      throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
    return mvMatrix;
  }

  function loadIdentity() {
    mvMatrix = Matrix.I(4);
  }


  function multMatrix(m) {
    mvMatrix = mvMatrix.x(m);
  }

  function mvTranslate(v) {
    var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
    multMatrix(m);
  }

  function mvRotate(ang, v) {
    var arad = ang * Math.PI / 180.0;
    var m = Matrix.Rotation(arad, $V([v[0], v[1], v[2]])).ensure4x4();
    multMatrix(m);
  }

  var pMatrix;
  function perspective(fovy, aspect, znear, zfar) {
    pMatrix = makePerspective(fovy, aspect, znear, zfar);
  }


  function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten()));
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten()));
  }

  var ZOOM = -125;
  
  var spin = 0;

  // Loads the vertices for a square into the graphics card
  var squareVertexPositionBuffer;
  function initBuffers() {
    
    squareVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
    vertices = [
         1.0,  1.0,  0.0,
        -1.0,  1.0,  0.0,
         1.0, -1.0,  0.0,
        -1.0, -1.0,  0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    squareVertexPositionBuffer.itemSize = 3;
    squareVertexPositionBuffer.numItems = 4;
        // Passes in vertex positions (could do this just once since only
    // squares are being drawn...binding is fast though)
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

  }
  
  var MAX_VELOCITY = 100;
  var PARTICLE_RADIUS = 1;
  var STAGE_WIDTH = 200;
  var STAGE_HEIGHT = 100;
  var COLORS = [
    204, 0, 0,
    255, 204, 0,
    170, 255, 0,
    0, 153, 204,
    25, 76, 153,
    102, 25, 153
  ];

  // Initializes a square with random color, position, etc.
  function Square() {
    var colorNum = Math.floor(Math.random() * (COLORS.length/3));
    
    this.r = COLORS[colorNum * 3] / 255.0;
    this.g = COLORS[colorNum * 3 + 1] / 255.0;
    this.b = COLORS[colorNum * 3 + 2] / 255.0;
    
    this.x = 0.0;
    this.y = 0.0;
    
    this.angle = Math.PI * 2 * Math.random();
    this.velocity = MAX_VELOCITY / 8 * 7 * Math.random() + MAX_VELOCITY / 8;
    
    this.rot = 1000 * Math.random();
  }

  // Functions have a prototype variable that can hold submethods (to make
  // classes). This draws a square with appropriate spin
  Square.prototype.draw = function(spin) {
    // The current matrix is pushed off (and then popped on) the stack
    // so that it's original state isn't modified by changes here
    mvPushMatrix();
    mvTranslate([this.x, this.y, 0.0]);
    
    if (spin)
      mvRotate(this.rot, [0, 1, 0]);
    
    // Sets colorUniform draw color
    gl.uniform3f(shaderProgram.colorUniform, this.r, this.g, this.b);
        
    // Passes in vertex positions (could do this just once since only
    // squares are being drawn...binding is fast though)
    //gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
    //gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    // Applies the spin transform
    setMatrixUniforms();
    
    // Draws the square (as a strip of triangles)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);

    mvPopMatrix();
  }
  
  Square.prototype.animate = function(timeDelta) {
    var nextX = this.x + .06;
    var nextY = this.y;
    var angle = this.angle;
    
    //var spin = document.getElementById("spin").checked;
    
    // Calculates the next position to draw the square in
    if (!document.testButtons.modes[2].checked) {
    
      nextX = this.x + Math.cos(this.angle) * this.velocity * (timeDelta / 1000);
      nextY = this.y + Math.sin(this.angle) * this.velocity * (timeDelta / 1000);
      
      if (nextX + PARTICLE_RADIUS * 2 > STAGE_WIDTH/2)
      {
        // If angle is between 3 o'clock and 6 o'clock
        if ((angle >= 0 && angle < Math.PI / 2))
        {
          angle = Math.PI - angle;
        }
        // If angle is between 12 o'clock and 3 o'clock
        else if (angle > Math.PI / 2 * 3)
        {
          angle = angle - (angle - Math.PI / 2 * 3) * 2
        }
      }
      
      // If particle is going to move off left side of screen
      if (nextX < STAGE_WIDTH/-2)
      {
        // If angle is between 6 o'clock and 9 o'clock
        if ((angle > Math.PI / 2 && angle < Math.PI))
        {
          angle = Math.PI - angle;
        }
        // If angle is between 9 o'clock and 12 o'clock
        else if (angle > Math.PI && angle < Math.PI / 2 * 3)
        {
          angle = angle + (Math.PI / 2 * 3 - angle) * 2
        }
      }
      
      // If particle is going to move off bottom side of screen
      if (nextY + PARTICLE_RADIUS * 2 > STAGE_HEIGHT/2)
      {
        // If angle is between 3 o'clock and 9 o'clock
        if ((angle > 0 && angle < Math.PI))
        {
          angle = Math.PI * 2 - angle;
        }
      }
      
      // If particle is going to move off top side of screen
      if (nextY < STAGE_HEIGHT/-2)
      {
        // If angle is between 9 o'clock and 3 o'clock
        if ((angle > Math.PI && angle < Math.PI * 2))
        {
          angle = angle - (angle - Math.PI) * 2;
        }
      }

      // Updates the position and angle of the square
    }
    
    this.x = nextX;
    this.y = nextY;
    this.angle = angle;

    this.rot += (90 * timeDelta) / 1000.0;
  }

  // Push squares into the squares array for drawing
  var squares = [];
  maxParticles = 1000;
  function initWorldObjects() {

    for (var i=0; i < maxParticles; i++) {
      squares.push(new Square());
    }
    
    // I moved this code from drawScene for efficiency's sake...shouldn't
    // create any problems
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    
    perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 200.0);

    loadIdentity();
    mvTranslate([0.0, 0.0, ZOOM]);
    
    document.testButtons.modes[0].checked = true;
  }

  // Draws each square in the squares array, unless Calculate is checked
  function drawScene() {
    var spin = document.getElementById("spin").checked;
    
    if (!document.testButtons.modes[1].checked) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
      for (var i in squares) {
        squares[i].draw(spin);
      }
    }

  }

  // Frame rate tracking occurs here, along with calling the movement
  // calculations for each square
  var lastTime = 0;
  var FRAME_TIMES = [];
  startTime = -1;
  framesRun = 0;
  SP500F = 0;
  function animate() {
    // Calculating FPS
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
      var elapsed = timeNow - lastTime;

      for (var i in squares) {
        squares[i].animate(elapsed);
      }
    }
    lastTime = timeNow;
    
    FRAME_TIMES.push(timeNow);
    
    // Calculating SP500F
    if (startTime < 0)
    {
      startTime = timeNow;
    }
    
    framesRun++;
    
    if (framesRun >= 500)
    {
      SP500F = timeNow - startTime;
      startTime = -1;
      framesRun = 0;
    }
    
    if (FRAME_TIMES.length > 60)
    {
      FRAME_TIMES.splice(0, 1);
    }
    
    var frameRate = document.getElementById("frameRate");
    var frameRateText = 1000 / ((timeNow - FRAME_TIMES[0]) / (FRAME_TIMES.length - 1)) + "";
    frameRateText = frameRateText.replace(/(^[^.]+\...).*/, "$1");
    frameRateText += (" FPS, " + SP500F/1000.0 + " SP500F");
    frameRate.innerHTML = frameRateText;
  }

  // Repeatedly draws and animates the squares
  function tick() {
    drawScene();
    animate();
  }

  // Called at start of program for setup
  function webGLStart() {
    var canvas = document.getElementById("speedTest-canvas");
    initGL(canvas);
    initShaders();
    initBuffers();
    initWorldObjects();

    gl.clearColor(1.0, 1.0, 1.0, 1.0);

    gl.clearDepth(1.0);
    
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    setInterval(tick, 15);
  }
  
  // Helper function for printing to console
  function log(msg) {
    setTimeout(function() {
        throw new Error(msg);
    }, 0);
  }
  
  function resetTiming()
  {
    framesRun = 0;
    startTime = -1;
    SP500F = 0;
    frameTimes = [];
  }
  

  // Updates the number of particles onscreen when the textfield is clicked
  function setParticles() {
    //If new value is greater, make additional particles
    if (parseInt(document.particleField.particles.value) > maxParticles) {
      for (var i = 0; i < parseInt(document.particleField.particles.value) - maxParticles; i++) {
        squares.push(new Square());
      }
    }
    else {
      for (var j = 0; j < maxParticles - parseInt(document.particleField.particles.value); j++) {
        squares.pop();
      }
    }
      
    maxParticles = document.particleField.particles.value;
    
    resetTiming();
  }




</script>


</head>


<body onload="webGLStart();">
  <canvas id="speedTest-canvas" style="border: none;" width="1255" height="625"> </canvas>
  
  <div id="controls" style="position:absolute; left:0px; top:0px">
    <form name=particleField>
      <input name=particles value=1000 type=text onClick="setParticles()" >
    </form>
    <div id="frameRate"> 
      </div>
    
    
    <form name="testButtons">
      <input type="radio" name="modes" value="All" onClick="resetTiming()" />All<br />
      <input type="radio" name="modes" value="Calculate" onClick="resetTiming()"/>Calculate<br />
      <input type="radio" name="modes" value="Draw" onClick="resetTiming()"/>Draw<br />
      </form>
  </div>
  
 

  
  <input type="checkbox" id="spin" /> Spin <br/>

<br/>
<br/>

</body>

</html>
